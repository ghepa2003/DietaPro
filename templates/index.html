<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>DietaPro - Web</title>
    <style>
      body{font-family:Arial;max-width:1100px;margin:20px auto}
      label{display:block;margin-top:6px}
      .meal{border:1px solid #ddd;padding:10px;margin:8px 0}
      .suggestions{position:relative}
      .suggestions-list{position:absolute;z-index:9999;background:#fff;border:1px solid #ccc;max-height:200px;overflow:auto;width:100%;box-sizing:border-box}
      .suggestions-list div{padding:6px;cursor:pointer}
      .suggestions-list div:hover{background:#eee}
      input.food-input{width:100%}
      .row{display:flex;gap:10px}
      .col{flex:1}
      #daily_totals_container{margin-top:12px;padding:8px;border:1px dashed #ccc}
      button{cursor:pointer}
      .diag-block{margin-top:8px;padding:8px;border:1px solid #ddd;background:#fafafa}
      .diag-warning{background:#fff7ed;border-color:#fde68a;color:#92400e}
      .diag-ok{background:#ecfdf5;border-color:#a7f3d0;color:#065f46}
      .diag-block ul{margin:6px 0 0 18px}
      .diag-note{font-size:12px;color:#666}
      .week-tabs{display:flex;gap:6px;margin:10px 0 4px}
      .week-tabs button{padding:6px 10px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer;transition:background .15s,border-color .15s}
      .week-tabs button.active{background:#e8f5e9;border-color:#2e7d32;color:#1b5e20} /* highlight current day */
      .section{border:1px solid #ddd;padding:8px;margin:8px 0}
      .section h4{margin:0 0 6px 0}
    </style>
  </head>
  <body>
    <h1>DietaPro - Pianificazione giornaliera</h1>
    <button id="helpBtn" style="margin-bottom:12px;">Guida / Aiuto</button>
    {% if username %}
      <p>Utente: <strong>{{ username }}</strong> — <a href="{{ url_for('logout') }}">Logout</a></p>
    {% endif %}

    <!-- Help modal (hidden by default) -->
    <div id="helpModal" aria-hidden="true" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:10000; align-items:center; justify-content:center;">
      <div role="dialog" aria-modal="true" style="background:#fff; max-width:900px; width:94%; max-height:85%; overflow:auto; padding:20px; margin:20px; border-radius:6px; box-shadow:0 10px 30px rgba(0,0,0,0.3);">
        <h2>Guida rapida a DietaPro</h2>
        <p>Questa applicazione calcola la ripartizione degli alimenti per pasto in modo da raggiungere le calorie e le percentuali di macronutrienti desiderate.</p>

        <h3>Flusso di utilizzo</h3>
        <ol>
          <li>Imposta le calorie giornaliere e le percentuali per ciascun pasto.</li>
          <li>Per ogni pasto scegli gli alimenti principali (carboidrati, proteine, grassi). Se selezioni della frutta e vuoi che contribuisca alle calorie principali imposta il <em>fruit ratio</em>.</li>
          <li>Usa <strong>Calcola solo questo pasto</strong> o <strong>Calcola giornata</strong> per ottenere le grammature suggerite.</li>
        </ol>

        <h3>La funzione di &quot;split&quot;</h3>
        <p>Lo <em>split</em> ti permette di vincolare la ripartizione energetica (kcal) di due o tre alimenti fra loro. Esempi di sintassi (una regola per riga):</p>
        <ul>
          <li><code>riso,pane=50</code> — riso e pane dovranno dividersi le kcal della coppia in un rapporto 50% / 50% (semettere 50 significa 50%).</li>
          <li><code>uova,noci=70,30</code> — uova 70% delle kcal della coppia, noci 30%.</li>
          <li><code>pasta,avocado,prosciutto=50,30,20</code> — split a 3 elementi con le percentuali indicate (si normalizzano se non sommano a 100).</li>
        </ul>
        <p>Note importanti sullo split:</p>
        <ul>
          <li>Lo split agisce solo sugli alimenti principali (non includere frutta o verdura nel campo dello split).</li>
          <li>Lo split introduce variabili di gruppo nel risolutore: questo può cambiare significativamente le grammature degli altri alimenti per rispettare contemporaneamente i vincoli sui macronutrienti.</li>
          <li>Usa lo split quando vuoi fissare la percentuale relativa di energia tra quegli alimenti, ma verifica sempre i risultati: lo split è comodo, ma può alterare il risultato voluto se la combinazione non è compatibile con i target di macronutrienti.</li>
        </ul>

        <h3>Parametro &quot;Min grammi per alimento&quot; (min_grams)</h3>
        <p>Questo valore impone un vincolo minimo esplicito (in grammi) per ogni alimento presente nella parte principale del pasto. Scopi principali:</p>
        <ul>
          <li>Protegge gli alimenti da azzeramenti numerici: quando si applicano split molto vincolanti alcuni alimenti possono risultare calcolati con 0 g — il valore <code>min_grams</code> evita che ciò accada sotto la soglia impostata.</li>
          <li>È un vincolo semplice e deterministico: imposta una soglia (es. 20 g) e l'ottimizzatore cercherà soluzioni che rispettino almeno quel valore per ogni alimento.</li>
        </ul>
        <p>Attenzione: un valore di <code>min_grams</code> troppo alto può rendere impossibile soddisfare contemporaneamente gli obiettivi calorici e di macronutrienti. In tal caso il risolutore fornirà la soluzione migliore possibile ma i residui (differenze dai target) potrebbero aumentare.</p>

        <h3>Consigli pratici</h3>
        <ul>
          <li>Prova con <code>min_grams</code> basso (5–20 g) e aumenta solo se osservi alimenti che vengono azzerati o diventano irrealistici.</li>
          <li>Controlla sempre i totali per pasto dopo aver applicato uno split: verifica che le kcal e i macronutrienti siano ancora coerenti con le tue aspettative.</li>
          <li>Usa lo split per migliorare il controllo su combinazioni che vuoi mantenere insieme (es. una fonte di grassi e una di proteine), ma fallo con moderazione e testa i risultati.</li>
        </ul>

        <h3>Alimenti con profilo macro misto</h3>
        <p>Alcuni alimenti (es. prosciutto crudo, formaggi light, salmone) hanno un profilo “misto” e possono apportare molte kcal da grassi pur essendo inseriti in <em>proteine</em>. Questo può alterare i risultati se nel calcolo ci si aspetta che ogni categoria contribuisca a un solo macro.</p>
        <ul>
          <li>Il calcolo corretto deve usare sempre l’intero profilo C/P/F di ogni alimento (4/4/9 kcal) nei vincoli e nella funzione obiettivo.</li>
          <li>Se un alimento in <em>proteine</em> ha molte kcal da grassi, valuta di spostarlo in <em>grassi</em> o di bilanciarlo con una fonte magra.</li>
          <li>Usa “Diagnostica scelte” per evidenziare rapidamente gli alimenti “misti”.</li>
        </ul>

        <div style="text-align:right; margin-top:12px;"><button id="helpClose">Chiudi</button></div>
      </div>
    </div>

    <!-- non mette action: tutto via AJAX -->
    <form id="mainForm" onsubmit="return false;">
      <fieldset style="border:1px solid #ccc; padding:8px; margin-bottom:10px;">
        <legend>Aggiungi alimento</legend>
        <div class="row">
          <div class="col">
            <label>Nome
              <div class="suggestions">
                <input id="new_nome" placeholder="es. quinoa" autocomplete="off">
              </div>
            </label>
          </div>
          <div class="col">
            <label>Categoria
              <select id="new_categoria">
                <option value="carboidrati">carboidrati</option>
                <option value="proteine">proteine</option>
                <option value="grassi">grassi</option>
                <option value="frutta">frutta</option>
                <option value="verdura">verdura</option>
              </select>
            </label>
          </div>
        </div>
        <div class="row">
          <div class="col"><label>Calorie <input id="new_calorie" type="number" step="0.1"></label></div>
          <div class="col"><label>Carboidrati (g/100g) <input id="new_carbo" type="number" step="0.1"></label></div>
          <div class="col"><label>Proteine (g/100g) <input id="new_prot" type="number" step="0.1"></label></div>
          <div class="col"><label>Grassi (g/100g) <input id="new_fat" type="number" step="0.1"></label></div>
        </div>
        <button type="button" id="btn_add_food">Aggiungi/aggiorna alimento</button>
        <span id="add_food_status" style="margin-left:8px;"></span>
      </fieldset>
      <h3>Impostazioni globali</h3>
      <label>Calorie totali giornata
        <input id="calorie_tot" name="calorie_tot" value="{{ defaults.calorie_tot if defaults is defined else 2000 }}">
      </label>
  <!-- min_ratio removed: replaced by explicit min_grams setting -->
      <label>Min grammi per alimento (protezione contro azzeramento)
        <input id="min_grams" name="min_grams" type="number" step="1" min="0" value="{{ (defaults.min_grams if defaults is defined and defaults.min_grams is defined else 0) }}">
      </label>

      <div class="row">
        {% for m in MEALS %}
        <div class="col">
          <label>Percentuale kcal {{ m }}
            <input name="perc_pasti_{{m}}" class="perc_pasti" value="{{ (defaults.perc_pasti[m] if defaults is defined else (0.25 if m=='colazione' else (0.4))) }}">
          </label>
        </div>
        {% endfor %}
      </div>

      <h4>Macro giornalieri (percentuali) — solo riferimento</h4>
      <div class="row">
        <div class="col"><label>Carbo <input id="macro_tot_carbo" value="{{ defaults.macro_tot.carbo if defaults is defined else 0.5 }}"></label></div>
        <div class="col"><label>Proteine <input id="macro_tot_prot" value="{{ defaults.macro_tot.prot if defaults is defined else 0.3 }}"></label></div>
        <div class="col"><label>Grassi <input id="macro_tot_fat" value="{{ defaults.macro_tot.fat if defaults is defined else 0.2 }}"></label></div>
      </div>

      <!-- NEW: Weekday navigation -->
      <div class="section">
        <h4>Giorni della settimana</h4>
        <div class="week-tabs" id="weekTabs">
          {% for d in WEEK_DAYS %}
            <button type="button" data-day="{{ d }}">{{ d.capitalize() }}</button>
          {% endfor %}
        </div>
      </div>

      <!-- NEW: Per-meal macro targets (shared across all days) -->
      <div class="section">
        <h4>Macro per pasto (percentuali) — uguali per tutti i giorni</h4>
        <div class="row">
          {% for m in MEALS %}
            <div class="col">
              <fieldset style="border:1px solid #eee;padding:6px">
                <legend style="font-size:12px;margin-left:8px">{{ m|capitalize }}</legend>
                <label>Carbo <input name="macro_{{m}}_carbo" value="{{ defaults.macro_pasti[m].carbo if defaults is defined else 0.5 }}"></label>
                <label>Prot <input name="macro_{{m}}_prot" value="{{ defaults.macro_pasti[m].prot if defaults is defined else 0.3 }}"></label>
                <label>Fat <input name="macro_{{m}}_fat" value="{{ defaults.macro_pasti[m].fat if defaults is defined else 0.2 }}"></label>
              </fieldset>
            </div>
          {% endfor %}
        </div>
      </div>

      <h3>Macro e scelte per pasto</h3>
      {% for m in MEALS %}
      <div class="meal" id="meal_{{m}}">
        <h4>{{ m|capitalize }}</h4>

        <!-- REMOVED: per-meal macro inputs inside meal (now centralized above) -->
        <div class="row">
          <div class="col"><label>Fruit ratio <input name="{{m}}_fruit_ratio" value="0.05"></label></div>
          <div class="col"><label>Veg ratio <input name="{{m}}_veg_ratio" value="0.0"></label></div>
        </div>

        <h5>Scelte alimenti (separare con virgola) — solo categoria corretta</h5>
        {% for cat in ['carboidrati','proteine','grassi','frutta','verdura'] %}
          <label>{{ cat }}:
            <div class="suggestions">
              <input class="food-input" data-cat="{{cat}}" id="{{m}}_{{cat}}" {% if cat =='carboidrati' %} placeholder="es. riso, pasta" {% elif cat == 'proteine' %} placeholder="es. pollo, tonno" {% elif cat == 'frutta' %} placeholder="es. mela, banana" {% elif cat == 'verdura' %} placeholder="es. insalata, broccoli" {% elif cat == 'grassi' %} placeholder="es. olio, burro" {% endif %} autocomplete="off"
                value="{{ (','.join((meal_choices.get(m, {}) or {}).get(cat, [])) if meal_choices is defined else '') }}">
            </div>
          </label>
        {% endfor %}

        <label>Split per questo pasto (una per riga, es. "riso,pane=50" o "uova,noci=70,30" — non includere frutta/verdura)</label>
        <textarea id="splits_{{m}}" rows="2" cols="60">{{ (splits_per_meal.get(m) or [])|join('\n') if splits_per_meal is defined else '' }}</textarea>

        <div style="margin-top:8px">
          <button type="button" onclick="calcSingle('{{m}}')">Calcola solo questo pasto </button>
          <button type="button" onclick="calcDay()">Calcola giornata </button>
          <button type="button" onclick="analyzeMeal('{{m}}')">Diagnostica scelte</button>
          <span style="margin-left:12px;">
            <span id="totals_{{m}}"></span>
          </span>
        </div>

        <div id="diag_{{m}}" class="diag-block" style="display:none"></div>
        <div id="perfood_{{m}}" style="margin-top:8px"></div>
      </div>
      {% endfor %}

      <p style="margin-top:10px; display:flex; gap:8px; align-items:center;">
        <button type="button" onclick="calcDay()">Calcola giornata </button>
        <button type="button" id="btn_save_state">Salva impostazioni utente</button>
        <span id="save_state_status" style="margin-left:8px"></span>
      </p>
    </form>

    <div id="daily_totals_container"></div>

    <script>
      (function(){
        // Safe JSON parse helpers to avoid runtime errors if server vars missing
        function parseJSON(s, fallback){
          try { return JSON.parse(s); } catch(e){ return fallback; }
        }

        const foodsByCat = parseJSON('{{ foods_by_cat|tojson | safe if foods_by_cat is defined else "{}" }}', {});
        const USERNAME = "{{ username or '' }}";
        const computeMealUrl = "{{ url_for('compute_meal') }}";
        const computeDayUrl  = "{{ url_for('compute_day') }}";
        const addFoodUrl     = "{{ url_for('add_food') }}";
        const getFoodUrl     = "{{ url_for('get_food') }}";
        const userStateUrl   = "{{ url_for('user_state_api') }}";
        window.MEALS = parseJSON('{{ MEALS|tojson | safe if MEALS is defined else "[]" }}', []);
        window.WEEK_DAYS = parseJSON('{{ WEEK_DAYS|tojson | safe if WEEK_DAYS is defined else "[]" }}', ["lunedi","martedi","mercoledi","giovedi","venerdi","sabato","domenica"]);
        const WEEKLY_FROM_SERVER = parseJSON('{{ weekly_state|tojson | safe if weekly_state is defined else "{}" }}', {});
        let currentDay = "{{ selected_day or '' }}";
        if(!currentDay || !(window.WEEK_DAYS||[]).includes(currentDay)){
          currentDay = (window.WEEK_DAYS && window.WEEK_DAYS[0]) || "lunedi";
        }

        // Build weekly state object (choices, fruit/veg ratios, splits per meal)
        function emptyDayState(){
          const o = {choices:{}, fruit_ratios:{}, veg_ratios:{}, splits_per_meal:{}};
          (window.MEALS||[]).forEach(m=>{
            o.choices[m] = {carboidrati:[], proteine:[], grassi:[], frutta:[], verdura:[]};
            o.fruit_ratios[m] = 0.0; o.veg_ratios[m] = 0.0; o.splits_per_meal[m] = "";
          });
          return o;
        }
        const WEEKLY = {};
        (window.WEEK_DAYS||[]).forEach(d=>{
          const src = (WEEKLY_FROM_SERVER && WEEKLY_FROM_SERVER[d]) || {};
          const day = emptyDayState();
          (window.MEALS||[]).forEach(m=>{
            const ch = ((src.choices||{})[m]) || {};
            day.choices[m] = {
              carboidrati: ch.carboidrati||[],
              proteine: ch.proteine||[],
              grassi: ch.grassi||[],
              frutta: ch.frutta||[],
              verdura: ch.verdura||[]
            };
            day.fruit_ratios[m] = parseFloat((src.fruit_ratios||{})[m]) || 0.0;
            day.veg_ratios[m]   = parseFloat((src.veg_ratios||{})[m]) || 0.0;
            const sp = (src.splits_per_meal||{})[m];
            day.splits_per_meal[m] = Array.isArray(sp) ? sp.join("\n") : (sp||"");
          });
          WEEKLY[d] = day;
        });

        function loadDayToDOM(day){
          const st = WEEKLY[day] || emptyDayState();
          (window.MEALS||[]).forEach(m=>{
            ['carboidrati','proteine','grassi','frutta','verdura'].forEach(cat=>{
              const el = document.getElementById(`${m}_${cat}`);
              if(el){ const arr = (st.choices[m] && st.choices[m][cat]) || []; el.value = arr.join(', '); }
            });
            const fr = document.querySelector(`input[name="${m}_fruit_ratio"]`);
            const vr = document.querySelector(`input[name="${m}_veg_ratio"]`);
            if(fr) fr.value = (st.fruit_ratios[m]||0).toString();
            if(vr) vr.value = (st.veg_ratios[m]||0).toString();
            const ta = document.getElementById(`splits_${m}`); if(ta) ta.value = st.splits_per_meal[m] || "";
            const tot = document.getElementById(`totals_${m}`); if(tot) tot.innerHTML = '';
            const pf  = document.getElementById(`perfood_${m}`); if(pf) pf.innerHTML = '';
            const dg  = document.getElementById(`diag_${m}`); if(dg){ dg.innerHTML=''; dg.style.display='none'; }
          });
          updateDailyTotalsFromDOM();
        }
        function collectDOMToDay(day){
          const st = WEEKLY[day] || emptyDayState();
          (window.MEALS||[]).forEach(m=>{
            const choices = {};
            ['carboidrati','proteine','grassi','frutta','verdura'].forEach(cat=>{
              const val = (document.getElementById(`${m}_${cat}`)?.value||'');
              choices[cat] = val.split(',').map(s=>s.trim()).filter(Boolean);
            });
            st.choices[m] = choices;
            st.fruit_ratios[m] = parseFloat(document.querySelector(`input[name="${m}_fruit_ratio"]`)?.value) || 0.0;
            st.veg_ratios[m]   = parseFloat(document.querySelector(`input[name="${m}_veg_ratio"]`)?.value) || 0.0;
            st.splits_per_meal[m] = document.getElementById(`splits_${m}`)?.value || "";
          });
          WEEKLY[day] = st;
        }

        // Setup week tabs and active highlight
        const weekTabs = document.getElementById('weekTabs');
        if(weekTabs){
          weekTabs.querySelectorAll('button[data-day]').forEach(btn=>{
            const d = btn.getAttribute('data-day');
            if(d === currentDay){ btn.classList.add('active'); btn.setAttribute('aria-pressed','true'); }
            btn.addEventListener('click', ()=>{
              collectDOMToDay(currentDay);
              weekTabs.querySelectorAll('button[data-day]').forEach(b=>{ b.classList.remove('active'); b.setAttribute('aria-pressed','false'); });
              currentDay = d;
              btn.classList.add('active'); btn.setAttribute('aria-pressed','true');
              loadDayToDOM(currentDay);
            });
          });
        }

        // autocomplete helpers
        function currentToken(val){
          const i = val.lastIndexOf(',');
          if(i === -1) return {prefix:'', token: val};
          return {prefix: val.slice(0, i+1), token: val.slice(i+1)};
        }

        function attachAutocomplete(input){
          const container = input.parentElement;
          let listDiv = container.querySelector('.suggestions-list');
          if(!listDiv){
            listDiv = document.createElement('div');
            listDiv.className = 'suggestions-list';
            container.appendChild(listDiv);
            listDiv.style.display = 'none';
          }
          input.addEventListener('input', ()=>{
            const cat = input.dataset.cat || 'carboidrati'; // read dynamically
            const raw = input.value;
            const {prefix, token} = currentToken(raw);
            const q = token.trim().toLowerCase();
            if(q.length === 0){ listDiv.style.display = 'none'; return; }
            const pool = foodsByCat[cat] || [];
            const matches = pool.filter(f => f.toLowerCase().includes(q)).slice(0,200);
            if(matches.length === 0){ listDiv.style.display = 'none'; return; }
            listDiv.innerHTML = '';
            matches.forEach(m => {
              const d = document.createElement('div'); d.textContent = m;
              d.addEventListener('mousedown', ()=>{
                input.value = (prefix + ' ' + m).replace(/^\s+/, '') + ', ';
                input.focus();
                setTimeout(()=>listDiv.style.display='none', 0);
              });
              listDiv.appendChild(d);
            });
            listDiv.style.display = 'block';
          });
          input.addEventListener('blur', ()=>{ setTimeout(()=>{ listDiv.style.display='none'; }, 150); });
        }

        // autocomplete for "Aggiungi alimento" (single token, filtered by selected category)
        function attachAddFoodAutocomplete(){
          const input = document.getElementById('new_nome');
          const selectCat = document.getElementById('new_categoria');
          const container = input.parentElement;
          let listDiv = container.querySelector('.suggestions-list');
          if(!listDiv){
            listDiv = document.createElement('div');
            listDiv.className = 'suggestions-list';
            container.appendChild(listDiv);
            listDiv.style.display = 'none';
          }
          async function fillFieldsFromServer(nome, categoria){
            try{
              const url = `${getFoodUrl}?categoria=${encodeURIComponent(categoria)}&nome=${encodeURIComponent(nome)}`;
              const r = await fetch(url);
              const data = await r.json();
              if(!r.ok || data.error) return;
              document.getElementById('new_calorie').value = data.calorie;
              document.getElementById('new_carbo').value   = data.carboidrati;
              document.getElementById('new_prot').value    = data.proteine;
              document.getElementById('new_fat').value     = data.grassi;
            }catch(e){ /* silent */ }
          }
          input.addEventListener('input', ()=>{
            const q = (input.value || '').trim().toLowerCase();
            if(q.length === 0){ listDiv.style.display = 'none'; return; }
            const cat = selectCat.value;
            const pool = foodsByCat[cat] || [];
            const matches = pool.filter(f => f.toLowerCase().includes(q)).slice(0,200);
            if(matches.length === 0){ listDiv.style.display = 'none'; return; }
            listDiv.innerHTML = '';
            matches.forEach(m => {
              const d = document.createElement('div'); d.textContent = m;
              d.addEventListener('mousedown', async ()=>{
                input.value = m;
                setTimeout(()=>listDiv.style.display='none', 0);
                await fillFieldsFromServer(m, cat);
              });
              listDiv.appendChild(d);
            });
            listDiv.style.display = 'block';
          });
          input.addEventListener('blur', ()=>{ setTimeout(()=>{ listDiv.style.display='none'; }, 150); });
          // when category changes, hide list and clear fields optionally
          selectCat.addEventListener('change', ()=>{
            listDiv.style.display = 'none';
          });
        }

        document.querySelectorAll('input.food-input').forEach(attachAutocomplete);
        attachAddFoodAutocomplete();

        // add-food handler
        document.getElementById('btn_add_food').addEventListener('click', async ()=>{
          const status = document.getElementById('add_food_status');
          status.textContent = '';
          const payload = {
            nome: (document.getElementById('new_nome').value||'').trim(),
            categoria: document.getElementById('new_categoria').value,
            calorie: parseFloat(document.getElementById('new_calorie').value||'0'),
            carboidrati: parseFloat(document.getElementById('new_carbo').value||'0'),
            proteine: parseFloat(document.getElementById('new_prot').value||'0'),
            grassi: parseFloat(document.getElementById('new_fat').value||'0')
          };
          try{
            const r = await fetch(addFoodUrl, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const data = await r.json();
            if(!r.ok || data.error){ throw new Error(data.error||'Errore'); }
            // aggiorna le liste locali per l'autocomplete
            const cat = data.item.categoria;
            const nome = data.item.nome;
            foodsByCat[cat] = foodsByCat[cat] || [];
            if(!foodsByCat[cat].includes(nome)) foodsByCat[cat].push(nome);
            foodsByCat[cat].sort((a,b)=>a.localeCompare(b));
            status.textContent = 'Salvato';
            status.style.color = 'green';
          }catch(e){
            console.error(e);
            status.textContent = 'Errore salvataggio';
            status.style.color = 'red';
          }
        });

        function readPercPasti(){
          const out = {};
          document.querySelectorAll('input[name^="perc_pasti_"]').forEach(i=>{
            const name = i.name.replace('perc_pasti_','');
            out[name] = parseFloat(i.value) || 0;
          });
          return out;
        }
  function readMacroPasti(){
          const out = {};
          (window.MEALS || []).forEach(function(m){
            out[m] = {
              carbo: parseFloat(document.querySelector('input[name="macro_' + m + '_carbo"]').value) || 0.5,
              prot:  parseFloat(document.querySelector('input[name="macro_' + m + '_prot"]').value) || 0.3,
              fat:   parseFloat(document.querySelector('input[name="macro_' + m + '_fat"]').value) || 0.2
            };
          });
          return out;
        }

        function readChoicesFor(meal){
          // reads from DOM (current day is already loaded)
          const out = {};
          ['carboidrati','proteine','grassi','frutta','verdura'].forEach(cat=>{
            const val = (document.getElementById(`${meal}_${cat}`).value || '');
            out[cat] = val.split(',').map(s=>s.trim()).filter(Boolean);
          });
          return out;
        }
        function readAllChoices(){
          const out = {};
          (window.MEALS || []).forEach(function(m){
            out[m] = readChoicesFor(m);
          });
          return out;
        }
        function readSplitsPerMeal(){
          const out = {};
          (window.MEALS || []).forEach(function(m){
            out[m] = document.getElementById('splits_' + m).value || "";
          });
          return out;
        }

        function updateDailyTotalsFromDOM(){
          let kcal=0, carbo=0, prot=0, fat=0;
          document.querySelectorAll('[id^="totals_"]').forEach(span=>{
            const k = parseFloat(span.querySelector('.kcal')?.textContent) || 0;
            const c = parseFloat(span.querySelector('.carbo')?.textContent) || 0;
            const p = parseFloat(span.querySelector('.prot')?.textContent) || 0;
            const f = parseFloat(span.querySelector('.fat')?.textContent) || 0;
            kcal += k; carbo += c; prot += p; fat += f;
          });
          const el = document.getElementById('daily_totals_container');
          el.innerHTML = `<h3>Totali giorno (visivi)</h3>
                          <p>${kcal.toFixed(1)} kcal — C: ${carbo.toFixed(1)} g P: ${prot.toFixed(1)} g F: ${fat.toFixed(1)} g</p>`;
        }

        function normalizeName(s){
          return (s || '').trim().toLowerCase().replace(/\s+/g,' ');
        }

        // NEW: map split tokens to closest names among selected main foods (carbo/prot/fat)
        function normalizeSplitNames(text, choices){
          const mainCats = ['carboidrati','proteine','grassi'];
          const pool = [];
          mainCats.forEach(cat => (choices[cat] || []).forEach(n => pool.push(n)));
          if(pool.length === 0) return text || '';
          const poolNorm = pool.map(name => ({ name, key: normalizeName(name) }));

          function bestMatch(tok){
            const k = normalizeName(tok);
            if(!k) return tok;
            // exact
            let cand = poolNorm.find(p => p.key === k);
            if(cand) return cand.name;
            // startsWith
            cand = poolNorm.find(p => p.key.startsWith(k));
            if(cand) return cand.name;
            // contains
            cand = poolNorm.find(p => p.key.includes(k));
            if(cand) return cand.name;
            return tok; // fallback: keep as-is
          }

          return (text || '').split(/\r?\n/).map(line=>{
            const raw = line.trim();
            if(!raw) return line;
            const idx = raw.indexOf('=');
            const left = idx >= 0 ? raw.slice(0, idx) : raw;
            const right = idx >= 0 ? raw.slice(idx+1) : '';
            const parts = left.split(',').map(s => s.trim()).filter(Boolean);
            if(parts.length < 2) return line;
            const mapped = parts.map(bestMatch);
            return mapped.join(',') + (idx >= 0 ? '=' + right : '');
          }).join('\n');
        }

        function sanitizeSplitsText(text, fruitList, vegList){
          const fruitSet = new Set((fruitList||[]).map(normalizeName));
          const vegSet   = new Set((vegList||[]).map(normalizeName));
          const lines = (text || '').split(/\r?\n/);
          const kept = [];
          let removed = 0;
          for(const line of lines){
            const raw = line.trim();
            if(!raw) { kept.push(line); continue; }
            const left = raw.split('=')[0] || '';
            const parts = left.split(',').map(s=>normalizeName(s)).filter(Boolean);
            if(parts.length >= 2){
              const a = parts[0], b = parts[1];
              const hit = fruitSet.has(a) || fruitSet.has(b) || vegSet.has(a) || vegSet.has(b);
              if(hit){ removed++; continue; }
            }
            kept.push(line);
          }
          return { text: kept.join('\n'), removed };
        }

        // NEW: auto-equal split for proteins (keeps up to 3 protein items present)
        function generateAutoSplitForProteins(choices, existingSplitsText){
          const prot = (choices && choices.proteine) ? choices.proteine.filter(Boolean) : [];
          if(prot.length < 2) return '';
          // if existing splits already reference >=2 protein names together, skip
          const existing = (existingSplitsText||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
          const protSet = new Set(prot.map(normalizeName));
          for(const line of existing){
            const left = (line.split('=')[0]||'').split(',').map(s=>normalizeName(s)).filter(Boolean);
            const countProt = left.reduce((acc,n)=> acc + (protSet.has(n)?1:0), 0);
            if(countProt >= 2) return ''; // user already defined a protein split
          }
          const n = Math.min(prot.length, 3);
          const names = prot.slice(0, n);
          // equal perc summing to 100
          const base = Math.floor(100 / n);
          const rem = 100 - base*n;
          const percs = Array.from({length:n}, (_,i)=> base + (i < rem ? 1 : 0));
          return `${names.join(',')}=${percs.join(',')}`;
        }

        window.calcSingle = function(meal){
          collectDOMToDay(currentDay); // keep WEEKLY updated
          const choices = readChoicesFor(meal);
          const rawSplits = document.getElementById(`splits_${meal}`)?.value || "";
          const sanitized = sanitizeSplitsText(rawSplits, choices.frutta, choices.verdura);
          const normalizedSplits = normalizeSplitNames(sanitized.text, choices);
          const autoProtSplit = generateAutoSplitForProteins(choices, normalizedSplits); // NEW
          const splitsToSend = [normalizedSplits, autoProtSplit].filter(Boolean).join('\n'); // NEW

          const payload = {
            meal: meal,
            day: currentDay,
            calorie_tot: parseFloat(document.getElementById('calorie_tot').value) || 2000,
            perc_pasti: readPercPasti(),
            macro_pasti: readMacroPasti(),
            choices: choices,
            fruit_ratio: parseFloat(document.querySelector(`input[name="${meal}_fruit_ratio"]`)?.value) || 0,
            veg_ratio: parseFloat(document.querySelector(`input[name="${meal}_veg_ratio"]`)?.value) || 0,
            splits_text: splitsToSend, // CHANGED
            min_grams: parseFloat(document.getElementById('min_grams').value) || 0.0,
          };

          fetch(computeMealUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify(payload)
          })
          .then(async r=>{ const t = await r.text(); try{ var d = t?JSON.parse(t):null; }catch(e){ var d=null; }
                           if(!r.ok) throw new Error((d&& (d.error||d.message)) || t || ('HTTP '+r.status));
                           if(d && d.error) throw new Error(d.error); return d; })
          .then(data=>{
            const t = data.totals || {};
            const totalsSpan = document.getElementById(`totals_${meal}`);
            const requested = (data.requested_kcal !== undefined) ? parseFloat(data.requested_kcal) : null;
            const kcalDelta = (data.kcal_delta !== undefined) ? parseFloat(data.kcal_delta) : (requested !== null ? (t.kcal - requested) : null);
            // macro breakdown
            const mb = data.macro_breakdown || {};
            const carboPct = ((mb.carbo && mb.carbo.percent) ? mb.carbo.percent : 0.0).toFixed(1);
            const protPct = ((mb.proteine && mb.proteine.percent) ? mb.proteine.percent : 0.0).toFixed(1);
            const fatPct  = ((mb.grassi && mb.grassi.percent) ? mb.grassi.percent : 0.0).toFixed(1);
            totalsSpan.innerHTML = `Totali pasto: <span class="kcal">${(t.kcal||0).toFixed(1)}</span> kcal ` +
                                   (requested !== null ? ` (richiesti: <strong>${requested.toFixed(1)}</strong> kcal, delta: <strong>${kcalDelta >= 0 ? '+' : ''}${kcalDelta.toFixed(1)}</strong> kcal)` : '') +
                                   ` — C: <span class="carbo">${(t.carbo||0).toFixed(1)}</span> g P: <span class="prot">${(t.proteine||0).toFixed(1)}</span> g F: <span class="fat">${(t.grassi||0).toFixed(1)}</span> g` +
                                   `<br><small>Macro % (kcal): C ${carboPct}% • P ${protPct}% • F ${fatPct}%</small>`;
            const pfDiv = document.getElementById(`perfood_${meal}`);
            let html = "<ul>";
            data.per_food.forEach(p => {
              html += `<li>${p.nome}: ${p.grammi.toFixed(1)} g — ${p.kcal.toFixed(1)} kcal (C:${p.carbo.toFixed(1)} P:${p.proteine.toFixed(1)} F:${p.grassi.toFixed(1)})</li>`;
            });
            html += "</ul>";
            pfDiv.innerHTML = html;
            updateDailyTotalsFromDOM();
          })
          .catch(err=>{
            console.error(err);
            alert('Errore calcolo pasto: ' + (err?.message||''));
          });
        };

        window.calcDay = function(){
          collectDOMToDay(currentDay);
          const allChoices = readAllChoices();
          const raw = readSplitsPerMeal();
          const sanitizedPerMeal = {};
          (window.MEALS || []).forEach(function(m){
            const s = sanitizeSplitsText(raw[m] || "", allChoices[m]?.frutta || [], allChoices[m]?.verdura || []);
            const norm = normalizeSplitNames(s.text, allChoices[m]);
            const autoProtSplit = generateAutoSplitForProteins(allChoices[m], norm); // NEW
            sanitizedPerMeal[m] = [norm, autoProtSplit].filter(Boolean).join('\n');  // CHANGED
          });

          const payload = {
            day: currentDay,
            calorie_tot: parseFloat(document.getElementById('calorie_tot').value) || 2000,
            perc_pasti: readPercPasti(),
            macro_pasti: readMacroPasti(),
            choices: allChoices,
            fruit_ratios: (function(){ const o={}; (window.MEALS || []).forEach(function(m){ o[m] = parseFloat(document.querySelector('input[name="'+m+'_fruit_ratio"]')?.value) || 0; }); return o; })(),
            veg_ratios:   (function(){ const o={}; (window.MEALS || []).forEach(function(m){ o[m] = parseFloat(document.querySelector('input[name="'+m+'_veg_ratio"]')?.value) || 0; }); return o; })(),
            splits_per_meal: sanitizedPerMeal,
            min_grams: parseFloat(document.getElementById('min_grams').value) || 0.0,
          };

          fetch(computeDayUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify(payload)
          })
          .then(async r=>{ const t = await r.text(); try{ var d = t?JSON.parse(t):null; }catch(e){ var d=null; }
                           if(!r.ok) throw new Error((d&& (d.error||d.message)) || t || ('HTTP '+r.status));
                           if(d && d.error) throw new Error(d.error); return d; })
          .then(data=>{
            const res = data.results || {};
            for(const meal in res){
              const t = res[meal].totals || {};
              const totalsSpan = document.getElementById(`totals_${meal}`);
              const requested = (res[meal].requested_kcal !== undefined) ? parseFloat(res[meal].requested_kcal) : null;
              const kcalDelta = (requested !== null) ? (t.kcal - requested) : null;
              // per-meal macro percent (from server)
              const mp = res[meal].macro_percent || {};
              const cPct = (mp.carbo !== undefined) ? mp.carbo.toFixed(1) : '0.0';
              const pPct = (mp.proteine !== undefined) ? mp.proteine.toFixed(1) : '0.0';
              const fPct = (mp.grassi !== undefined) ? mp.grassi.toFixed(1) : '0.0';

              totalsSpan.innerHTML = `Totali pasto: <span class="kcal">${(t.kcal||0).toFixed(1)}</span> kcal ` +
                                     (requested !== null ? ` (richiesti: <strong>${requested.toFixed(1)}</strong> kcal, delta: <strong>${kcalDelta >= 0 ? '+' : ''}${kcalDelta.toFixed(1)}</strong> kcal)` : '') +
                                     ` — C: <span class="carbo">${(t.carbo||0).toFixed(1)}</span> g P: <span class="prot">${(t.proteine||0).toFixed(1)}</span> g F: <span class="fat">${(t.grassi||0).toFixed(1)}</span> g` +
                                     `<br><small>Macro % (kcal): C ${cPct}% • P ${pPct}% • F ${fPct}%</small>`;

              const qf = res[meal].quant_frutta;
              const qv = res[meal].quant_verdura;
              if(qf !== null && qf !== undefined){ totalsSpan.innerHTML += ` <br><small>Frutta: ${qf.toFixed(1)} g</small>`; }
              if(qv !== null && qv !== undefined){ totalsSpan.innerHTML += ` <br><small>Verdura: ${qv.toFixed(1)} g</small>`; }
              const pfDiv = document.getElementById(`perfood_${meal}`);
              let html = "<ul>";
              (res[meal].per_food||[]).forEach(p => {
                html += `<li>${p.nome}: ${p.grammi.toFixed(1)} g — ${p.kcal.toFixed(1)} kcal (C:${p.carbo.toFixed(1)} P:${p.proteine.toFixed(1)} F:${p.grassi.toFixed(1)})</li>`;
              });
              html += "</ul>";
              pfDiv.innerHTML = html;
            }
            const td = data.total_day || {};
            const el = document.getElementById('daily_totals_container');
            // daily macro percent from server
            const dmp = data.daily_macro_percent || {};
            const dc = (dmp.carbo !== undefined) ? dmp.carbo.toFixed(1) : '0.0';
            const dp = (dmp.proteine !== undefined) ? dmp.proteine.toFixed(1) : '0.0';
            const df = (dmp.grassi !== undefined) ? dmp.grassi.toFixed(1) : '0.0';
            el.innerHTML = `<h3>Totali giorno (calcolo)</h3>
                            <p>${(td.kcal||0).toFixed(1)} kcal — C: ${(td.carbo||0).toFixed(1)} g P: ${(td.proteine||0).toFixed(1)} g F: ${(td.grassi||0).toFixed(1)} g</p>` +
                         `<p><small>Media percentuale contributo macro (kcal): C ${dc}% • P ${dp}% • F ${df}%</small></p>`;
          })
          .catch(err=>{
            console.error(err);
            alert('Errore calcolo giornata: ' + (err?.message||''));
          });
        };

        // === Persistenza locale ===
        function persistKeyFor(el){
          const ns = USERNAME ? ('user:' + USERNAME + ':') : '';
          if(el.name && el.name.trim()) return 'persist:' + ns + 'name:' + el.name.trim();
          if(el.id && el.id.trim())     return 'persist:' + ns + 'id:' + el.id.trim();
          return null;
        }
        function restorePersisted(){
          const fields = document.querySelectorAll('input, textarea, select');
          fields.forEach(el=>{
            const key = persistKeyFor(el);
            if(!key) return;
            const saved = localStorage.getItem(key);
            if(saved !== null){
              // handle numeric inputs gracefully
              if(el.type === 'number'){
                el.value = saved;
              }else{
                el.value = saved;
              }
            }
          });
        }
        function attachPersistHandlers(){
          const save = (el)=>{
            const key = persistKeyFor(el);
            if(!key) return;
            localStorage.setItem(key, el.value ?? '');
          };
          const fields = document.querySelectorAll('input, textarea, select');
          fields.forEach(el=>{
            el.addEventListener('input', ()=>save(el));
            el.addEventListener('change', ()=>save(el));
          });
        }

        // Ripristina e setup
        // restorePersisted(); // opzionale: abilita se vuoi ripristino locale
        attachPersistHandlers();
        loadDayToDOM(currentDay);
        updateDailyTotalsFromDOM();
        document.querySelectorAll('[id^="totals_"]').forEach(el => { el.innerHTML = ''; });
        document.querySelectorAll('[id^="perfood_"]').forEach(el => { el.innerHTML = ''; });

        // Salvataggio stato utente lato server (sessione utente)
        async function saveUserState(){
          collectDOMToDay(currentDay);
          const status = document.getElementById('save_state_status');
          status.textContent = '';
          const payload = {
            calorie_tot: parseFloat(document.getElementById('calorie_tot').value) || 2000,
            perc_pasti: readPercPasti(),
            macro_tot: {
              carbo: parseFloat(document.getElementById('macro_tot_carbo').value) || 0.5,
              prot:  parseFloat(document.getElementById('macro_tot_prot').value) || 0.3,
              fat:   parseFloat(document.getElementById('macro_tot_fat').value) || 0.2,
            },
            macro_pasti: readMacroPasti(), // shared across the week
            // keep current-day fields for backward compatibility
            choices: readAllChoices(),
            fruit_ratios: (function(){ const o={}; (window.MEALS || []).forEach(function(m){ o[m] = parseFloat(document.querySelector('input[name="'+m+'_fruit_ratio"]').value) || 0; }); return o; })(),
            veg_ratios:   (function(){ const o={}; (window.MEALS || []).forEach(function(m){ o[m] = parseFloat(document.querySelector('input[name="'+m+'_veg_ratio"]').value) || 0; }); return o; })(),
            splits_per_meal: (function(){ const o={}; (window.MEALS || []).forEach(function(m){ o[m] = document.getElementById('splits_' + m).value || ''; }); return o; })(),
            min_grams: parseFloat(document.getElementById('min_grams').value) || 0.0,
            // NEW: full weekly state and selected day
            weekly: WEEKLY,
            selected_day: currentDay,
          };
          try{
            const r = await fetch(userStateUrl, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const data = await r.json();
            if(!r.ok || data.error){ throw new Error(data.error || 'Errore salvataggio'); }
            status.textContent = 'Impostazioni salvate';
            status.style.color = 'green';
          }catch(e){
            console.error(e);
            status.textContent = 'Errore salvataggio';
            status.style.color = 'red';
          }
        }
        const btnSave = document.getElementById('btn_save_state');
        if(btnSave){ btnSave.addEventListener('click', saveUserState); }

        // Help modal handlers
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const helpClose = document.getElementById('helpClose');
        function openHelp(){
          if(!helpModal) return;
          helpModal.style.display = 'flex';
          helpModal.setAttribute('aria-hidden','false');
          // focus first focusable element inside modal
          const btn = helpModal.querySelector('button'); if(btn) btn.focus();
        }
        function closeHelp(){
          if(!helpModal) return;
          helpModal.style.display = 'none';
          helpModal.setAttribute('aria-hidden','true');
          if(helpBtn) helpBtn.focus();
        }
        if(helpBtn) helpBtn.addEventListener('click', openHelp);
        if(helpClose) helpClose.addEventListener('click', closeHelp);
        if(helpModal){
          helpModal.addEventListener('click', function(e){ if(e.target === helpModal) closeHelp(); });
          document.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeHelp(); });
        }
      })();
    </script>
  </body>
</html>
